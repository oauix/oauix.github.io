<!doctype html>
<html>
	<head>
		<title>java-集合</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="说明书">
		<meta name="keywords" content="数据类型,oracle,数据库">
		<link rel="stylesheet" href="css/java.css" type="text/css">
		<style>
		
		</style>
	</head>
	<body>
		<div class="body">
			<div class="content">
				<h2>集合：</h2>
				<p>list set Arrayslist LinkedList HashSet</p>
				<p>*list是可重复集,且有序; set不可重复集，大部分是无序</p>
				<p>1.Collection c=new ArrayList();Collection c=new HashSet();//创建集合</p>
				<p>2.常用方法：add() contains()[是否含元素] addAll() containsAll()[是否含一个集合] clean() size() isEmpty()[是否不包含如何元素]，remove()</p>
				<p>3.hasNext() next()就是为while设计的，俩个方法只能用一次，多次会报错</p>
					<p style="text-indent:4em">Iterator ite=obj.iterator();//创建接口</p>
					<p style="text-indent:4em">While(ite.hasNext){</p>
							<p style="text-indent:6em">Object obj=ite.next();</p>
							<p style="text-indent:6em">System.out.print(obj);</p>
							<p style="text-indent:6em">If(obj.equals(“str”)){</p>
								<p style="text-indent:8em">Ite.remove();</p>
							<p style="text-indent:6em">}</p>
					<p style="text-indent:4em">}</p>
					<p style="text-indent:4em">增强for</p>
					<p style="text-indent:4em">for(Object obj: ite){</p>
						<p style="text-indent:6em">System.out.print(obj);</p>
						<p style="text-indent:6em">Obj.remove(“元素”);//不能用集合的ite.remove()方法去删除，会出异常</p>
					<p style="text-indent:4em">}</p>
				
				<h3>线性表ArrayList与双向性表LinkedList的方法</h3>
					<p>*LinkedList是像项链的东西</p>
					<p>1.get() </p>
					<p>*String a=obj.get(int b);获取集合中的元素，ArrayList时正常，LinkedList到中间有性能差异</p>
					<p>2.set()</p>
					<p>*String a=obj.set(int a,str);更换指定元素为str，并返回原元素。</p>
					<p>3.remove()</p>
					<p>*String a=obj.remove(int a);删除指定元素，并将该元素返回。</p>
					<p>4.subList()</p>
					<p>*List a=obj.subList(int a,int b)截取中的元素为另一个集合，它只是指向原集合地址，改变子集合，原集合也会变，改原集合时，操作子集合会报错。</p>
				
				<h3>集合与数组转换</h3>
					<p>1.toArray();</p>
					<p>*  String[] a=ojb.toArray(new String(){});一个集合转换为数组，</p>
					<p>*  new toArray(){}这个数组长度小时，就直接撑大。</p>
					<p>*  new toArray(){}这个数组长度大时,把元素全放进去,然后+1一个为null，后面多的保持不变</p>
					<p>2.asList()</p>
					<p>*List<String> a=Arrays.asList(arr);</p>
					<p>*集合与数组共享地址，对其修改时，数组和集合都会随之改变，注意：不能对转换过来的集合增删元素操作，会报错</p>
				

				<h3>集合排序</h3>
					<p>#Collections.sort(obj);该方法必须要有比较规则。</p>
					<p>*比较算法(规则)不同，会产生不同排序</p>
					<p>*String类型提供了字符串大小比较的方法：</p>
						<p style="text-indent:4em">Str.compareTo(str2);str与str2比较</p>
					<p>*java公司定义：compareTo方法有三种状态：</p>
						<p style="text-indent:4em">Int n= Str.compareTo(str2)；n&gt;0,Str大，n&lt;0，str2大；n=0,str=str2.</p>
					<p>*很多java给的类都有compraceTo方法，故把他写在一个父类上，这个类叫Compraable。</p>
					<p>*常见有compareTo方法的类有：String Date Integer</p>
					<p>*compareTo非常严谨，一般自定义类(自己建的类)不建议实行compareTo方法。</p>
					<p>#自定义排序(自定义排序规则)：</p>
					<p>*重写方法：Collections.sort(list,比较器);</p>
					<p>*自定义比较有个接口：Comparator</p>
					<p>*下图案列：</p>
					<p>*调用：Collections.sort(list,new ByAge() );</p>
<pre style="background:#ccf2d0;border-radius: 7px;box-shadow: 1px 2px 10px #888">

	class byage implements Compartor<Cat>{
		/**
		*自定义的比较算法：按照猫对象的年龄比较大小
		*如果返回&lt;0；则o1&lt;o2;
		*如果返回&gt;0；则o1&gt;o2;
		*如果返回=0；则o1=o2;
		public int compare(Cat o1,Cat o2){
			int a1=o1.age;
			int a2=o2.age;
			return a1-a2;
			//if(a1>a2){return 1;}
			//if(a1&gt;a2){return -1;}
			//else{return 0;}
		}
	}
</pre>
			</div>
		</div>
	</body>
</html>