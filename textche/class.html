<div class="textshowche">
  <h5><a href='#'>抽象类</a></h5>
  <div class="show">
     <p>由abstract修饰,包含抽象方法的类必须是抽象类</p>
     <p>抽象类不能被实例化,抽象类是需要被继承的，</p>
     <p>可以包含抽象方法，为所有子类提供了统一的入口,每个子类的实现不同，但入口是一致的</p>
     <p></p>
  </div>
  <div class="bottom">@2017-09-28 20:02:09 小ol鱼 阅读(0) 评论(0) <a href="#">编辑</a></div>
</div>
<div class="textshowche">
  <h5><a href='#'>内部类</a></h5>
  <div class="show">
     <p>1.在类的内部，默认该类的外部类不可见，一定要用，该类.内部类来访问,创建对象:Outer.Inner in = new Outer().new Inner()</p>
     <p>2.内部类有一个隐式的实例化 即[外部类名 不知名 = new 外部类名()],可以直接拿来用</p>
	 <p>内部类通常只服务于外部类，对外不具备可见性</p>
     <p></p><br/>
     <p>题:Outer类中定义了一个成员内部类Inner，需要在main()方法中创建 Inner类实例对象</p>
     <p>一定要在别的类访问:Outer.Inner in = new Outer().new Inner();在外面对象的基础上创建对象</p>
	 <br/>
     <p>匿名内部类:</p>
     <p>1)若想创建一个类(子类)的对象，并且对象只被创建一次,此时该类不必命名，称为匿名内部类</p>
     <p>而且该类是继承或实现接口的类，不然以什么基础创建</p>
     <p>创建格式：父类名[接口] obj =new 父类名[接口]（）{内部类内容}；</p>
     <p>在这里只是告诉初学者对于匿名内部类不要想的太多，而要这么想：匿名内部类就是重写父类或接口的方法，实现某种功能。可以匿名内部类对象.方法名()可以调用</p>
     <p>2)匿名内部类若想访问外部的外部变量，这个外部变量必须是final的[老师讲课带过,待测]</p>
     <p>[网上说是:]匿名内部类不能访问外部类方法中的局部变量，除非变量被声明为final类型 [扩展-原因]</p>
     <p>最后，Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。</p>
	 <br/>
	 <p>包装类：</p>
	 <p>Integer Long Double Short Float Byte Char Boolean	Char Boolean在java.lang.Object包内 其他都在java.lang.Number</p>
	 <p># 拆箱和装箱：8种基本转给包装类称之为装箱，反之为拆箱</p>
	 <p># 拆箱有对隐形方法：intValue();doubleValue();等</p>
  </div>
  <div class="bottom">@2017-09-28 20:03:49 小ol鱼 阅读(0) 评论(0) <a href="#">编辑</a></div>
</div>