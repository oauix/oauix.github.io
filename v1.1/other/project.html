<!doctype html>
<html>
	<head>
		<title>项目开发扩展</title>
		<meta charset="utf-8" />
		<meta name="decription" content="说明书" />
		<meta name="keywords" content="关键词" />
		<!-- 显示区缩放 适用于手机 -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="../css/web.css" type="text/css" />
		<style>
			
		</style>
	</head>
	<body>
		<div class="body">
			<div class="content">
				<h4>1.[怎么查api]</h4>
				<h4>2.[绝对路径常用用法]</h4>

				<p>&lt;%@ taglib uri="" prefix="c" %></p>
				<p>&lt;c:set var="basePath" value="${pageContext.request.contextPath}">&lt;/c:set></p>
				<p>&lt;script type="text/javascript"</p> src="${basePath}/js/jquery-3.2.1.js">&lt;/script></p>
				<h4>3.SQL</h4>
				<p>? 用法,一些函数new()</p>
				<p>将sql语句写在.sql文件中,用:source命令,格式: source src;</p>
				<h4>jquery</h4>
				<p>1. .empty;清空数据</p>
				<p>2. .append("数据");追加数据</p>
				<p>3. .replace(str,"替换数据") 数据替换</p>
				<p>4. .on .data</p>
<pre>
	$(document).ready(function(){
		//单击id为pa下class为pr时触发method方法
		$("#pa").on("click",".pr",method);
		//将resule.name绑定到#page的pageche属性
		$("#page").data("pageche",resule.name);
		//获取#page的pageche属性值
		$("#page").data("pageche");
	});
</pre>
				<p>5.$(this).is(':checked') 是否被选中,true选中 </p>
				<h4>数据转换</h4>
				<p>1.str=="xiaoyu"?"正确":"错误";</p>
				<p>2.日期转换: new Date(list[i].endDate).toLocaleDataString();</p>
				<h4>bootstrap[前端界面框架]</h4>
				<h4>debugger[js中调试一种,需要f12调试模式]</h4>
				<h4>mysql取指定数据</h4>
				<p>select * from User <span style="color:red">limit</span> 2,3 --2代表记录大于2开始取,3代表取几条记录</p>
				<h4>引用实体类加前缀,#{User.web}[多表字段冲突]</h4>
				<p>dao方法中要用@para注明</p>
				<h4>默认自动选中输入</h4>
				<p>document.getElementById("inp").focus();</p>
				<h4>网页字体设置</h4>
				<p>所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
				<p>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是</p>
				<p>这些浏览器会忽略用rem设定的字体大小。下面就是：p {font-size:14px; font-size:.875rem;}</p>
				<h4>springmvc请求传参数</h4>
				<p>springmvc自动调用set方法注入,直接给方法传参加就行</p>
				<h4>引入.jsp文件</h4>
				<p>&lt;%@include file="../common/page.jsp" %></p>
				<p>在B.jsp 中，使用&lt;%@ include file=”A.jsp”%> ，那么就是把 A.jsp 的内容 原封不动  引入到 B.jsp 中。另外注意编码问题，</p>

				<h4>mybatis 中的where 用法</h4>
<pre>
	&lt;where>
	  &lt;if test="project.name!=null and project.name>
		 p.name like concat("%",#{project.name},"%");
	  &lt;/if>
	  &lt;if test="project.valid!=null">
		 and p.valid=#{project.valid}
	  &lt;/if>
	&lt;/where>
	limit #{pageObject.ab},#{pageObject.val}//放在最后


	pulic int getnum(@Param("project")Project project){};//DAO里自动传参
</pre>
				<h4>&lt;url-pattern>*.do&lt;/url-pattern></h4>
				<p>1.中间是[/]：请求响应可以处理servlet请求,不能处理html,比如login.html找不到</p>
				<p>2.中间是[/*]：启动不报错,但处理器无法工作,不响应请求</p>
				<p>3.中间是[*]: 直接报错！</p>
				<p>4.中间是[/*.]: 直接报错！</p>
				<p>5.[*.]这样才是正确的</p>

				<h4>BaseDao&lt;T></h4>

					<p>类上定义的泛型用于约束类中的方法参数类型,方法的返回值类型或属性类型</p>
					<p>用接口泛型类型统一 serice 与 dao的入口</p>
<pre>
	public interface BaseDao&lt;T>{
		int insertObject(T t);			
	}
	public interface UserDao extends BaseDao{
						
	}
</pre>
			<h4>文件上传</h4>
<pre>
	 *	Assert.assertEquals(1,rows);/测试是否通过
	 *
	 *	commons.fileupload  //上传支持jar包
	 *	common-codec 1.3//md5加密包
	 *	DigestUtils.md5Hex("hello word");//字符串加密
	 *	MultipartFile [文件对象]
	 *
	 *	service:
	 *	void saveObject(String title,Integer id,MultipertFile mult){
	 *		String oFileName=mult.getOriginalFilename();/获取名字
	 *		byte[] fileBytes=mult.getBytes();/获取文件字节
	 *		File dest=new file("d:/upload/"+oFileName);//路径+名字
	 *		mult.transferTo(dest);//输出内容动作 可能有异常
	 *		
	 *		mult.getContType();/获取文件类型
	 *
	 *		DigestUtils.md5Hex(fileBytes);/加密文件内容
	 *	}
	 *
	 *	Controller:
	 *	@Conterller
	 *	@RequestMapping("/attach")
	 *	public class AttachementController{
	 *		@RequestMapping("/save")
	 *		public JsonResult doSaveObject(String title,Integer id,MultipertFile mult){
	 *			service.saveObject(title,id,mult); //mult是input中属性name="mult"
	 *			return new JsonResult("THIS OK!");
	 *		}
	 *	}
	 *
	 *	JS+AJAX：
	 *	 from有个属性:enctype="multipart/form-data" //二进制传输
	 *	 $(document).read(function(){
	 *		$("#id").on("click",".btn-class",loadmethod) /绑定事件
	 *	 });
	 *	 function loadmethod(){
	 *		var url="attach/save";
	 *		$("#ids").data("name",object);//绑定数据参数
	 *		$("#ids").data("name",object);
	 *		$("#ids").load(url);//发送异步请求,并将数据加载到#ids容器内
	 *	 }

	 *	var tbody=$("#tbodyid");/添加东西
	 *	tbody.clear();
	 *	var tds="&lt;td>&lt;input type='checkbox' name='' value='[id]'>&lt;/td>"
	 *							+"&lt;td>[name]&lt;/td>"
	 *							+"&lt;td>[password]&lt;/td>";
	 *	for(var i in list){
	 *		var tr=$("&lt;tr>&lt;/tr>");
	 *		tr.data("id",list[i].id);/绑定一个id值
	 *		tr.append(
	 *			tds.replace("[id]",list[i].id).replace("[name]",list[i].name)
				.replace("[password]",list[i].password)
	 *		);
	 *
	 *	
		//异步上传表单数据
	 *	$("#formid").ajaxSubmit(URL,TYPE,data,DATATYPE,SUCCESS)  添加jquery.from.js包支持
</pre>
			
				
				<h4>UUID.randomUUID.toString()+FilenameUtils.getExtension(文件名)随即+扩展名</h4>
				<h4>文件下载</h4>
<pre>
	response.setContentType("appliction/octet-stream");
	response.setHeader("Content-disposition","attachment;filename="+file.getName());
	/跟进文件真实路径构建Path对象
	Path path=Paths.get(file.getPath());
	/将文件的字节码返回
	return Files.readAllByTES(path);
	/return file;
</pre>

				<h4>c常用快捷键</h4>
					<p>快速找类的快捷键：ctrl+shift+t</p>
					<p>快速查看本类的方法:ctrl+o</p>
					<p>快速注释：ctrl+shift+/</p>
					<p>快速导包：ctrl+shift+O</p>
			</div>		 
		</div>
	</body>
</html>  