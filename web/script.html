<!doctype html>
<html>
	<head>
		<title>javascript</title>
		<meta charset="utf-8" />
		<meta name="decription" content="说明书" />
		<meta name="keywords" content="关键词" />
		<!-- 显示区缩放 适用于手机 -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="css/web.css" type="text/css" />
		<style>
			span{font-size:1.1em;margin-left:1em;}
		</style>
	</head>
	<body>
		<div class="body">
			<div class="content">
				<h4>1.变量、null和undefined</h4>
				<p>声明变量:var i; 没有初始化的变量默认是:undefined</p>
				<p>null:程序中"无值"或"无对象",可以赋值null来清空变量内容</p>
				<p>undefined:变量未赋值，或对象属性不存在</p>
				<h4>2.运算符 || 关系运算 || boolean</h4>
				<p>运算符:与java雷同，但[/]除不同,结果可以为小数</p>
				<p>关系运算:与java雷同,"=="与"==="有区别,js中"=="比较俩值,"==="比较值+数据类型</p>
				<p>boolean:js中有隐形转换,boolean n=0,null,"",undefined,NaN时，n=false</p>
				<p> false[0,null,"",undefined,NaN](值都false)</p>
				
				<h4>3.typeof(n)//返回n的数据类型;isNan(n)//判断n是否为number值;</h4>
				<h4>4.内置对象:</h4>
				<div style="width:88%;margin:20px auto">
				<h5>1>.String:</h5>
				<p>n.length;</p>
				<p>charAt(n);lastcharAt(n)[从后开始查找];charCodeAt(n)[查到后返回Uniccode值];</p>
				<p>n.indexOf(str)[查找中间字符];n.lastindexOf(str)[从后开始查找];没有返回-1</p>
				<p>n.substring(start,end)[截取字符串，含前不含尾];</p>
				<p>n.replace(finstr,tostr)[更换字符串];</p>
				<p>x.split(byte);//拆分字符串</p>
				<h5>2>.Number:</h5>
				<p>toFixed(n);转换为字符串，并保留n位小数</p>
				<h5>3>.Array:</h5>
				<p>n.reverse();//f反向数组</p>
				<p>n.sort([b]);//数组排序，中间可以调方法，用来声明比较算法</p>
				<h5>4>.number:</h5>
				<h5>5>.date:</h5>
				<p>日期转换为字符串：toString();toLocaleTimeString()[根据本地时间把 Date 对象的时间部分转换为字符串];toLocaleDateString()</p>
				<h5>6>.regexp[正则表达式]:</h5>
				<p>表达式格式：var str=/这里写正则/;</p>
				<p>regexpobjcest.exec(str);//指出str字符串位置,返回该值</p>
				<p>regexpobjcest.test(str);//如果字符串regexpobjcest中含有字符串str就返回ture，n为正则表达式</p>
				<p>n.replace(str,tostr);str为正则表达式类型</p>
				<p>n.match(str);//获取正则表达式str匹配的字符串数组</p>
				<p>n.search(str);//返回正则表达式str的位置</p>
				<h5>7>.Function[函数]:</h5>
				<p>arguments对象，一种特殊的对象，可以访问函数实现与方法</p>
				<p>函数参数：</p>
<pre>
	function method(){
		alert(arguments.length);
		alert(arguments[0]);
	}
	method(10,30);//输出是2后才输出10；
</pre>
				<p>创建function函数一种方式：var add=new function("x","y","retrun x+y";)</p>
				<p>正常写法：</p>
<pre>
	function arguments(x,y){
		retrun x+y;
	}
</pre>
				<p style="color:red">function中的eval函数，计算字符串中的值，效果：</p>
<pre>
	var str="2+3"
	alert(str);//2+3
	alert(eval(str));//5
</pre>
				</div>
				<h4>5.外部对象：</h4>
				<div style="width:88%;margin:20px auto">
					<P>BOM-- Browser Objcect Model,浏览器对象模型,用访问操作浏览器窗口,没有标准</P>
					<h5>1>>.DOM文件操作对象[document]</h5>
					<p>Document Object Model,文档对象模型,用来操作文档,定义标准</p>
						<p style="color:red">获取与修改</p>
						<p>1.var n=document.getElementById(id);</p>
						<p>2.var m=document[objcect].getElementsByTagName("标签名");</p>
						<p>3.var m=document.getElementsByName("name属性,跟id一样");但获取的值是数组,用var user=document.getElementsByName("user")[0].value;</p>
						<p>n.nodeName;//节点名字，标签名或属性名</p>
						<p>n.nodeType;//节点类型，一般是value的值</p>
						<p>
							n.innerText;获取或设置对象起始和结束标签内的<span style="color:red;margin:1px">文本</span>
						</p>
						<p>n.innerHTML;获取或设置对象起始和结束标签内的HTML[全部内容]</p>
						<p>n.getAttribute("属性");根据属性获取属性里面的值</p>
						<p>id style className中的东西可以.出来，其他不是所有浏览器都支持[兼容问题]</p>
						<p>4.<i style="color:green">获取标签上一级标签</i>  用：object.parentNode;object指当前标签</p>
						<p style="color:red">创建节点</p>
						<p>1.var n=document.createElement("添加标签名");//创建节点</p>
						<p style="text-indent:4em">//设置节点信息</p>
						<p style="text-indent:4em">n.type="text";</p>
						<p style="text-indent:4em">n.value="mary";</p>
						<p>2.n.appendChild("添加标签名");//再继续追加</p>
						<p>3.n.insertBefore("添加标签名",refnote);//再继续追加,不过可以选择refnote标签前追加</p>
						<p style="color:red">删除节点</p>
						<p>object.removeChild("标签名");//删除object标签下的“标签名”标签</p>
					<h5>2>>.window对象</h5>
					<p>常用有:alert(str);confirm(str);//确认对话框</p>
					<p>周期定时器:setInterval(exp,time)[exp为函数名,不加()];clearInterval(tID);//停止对象定时器</p>
					<p>一次性定时器:setTimeout(exp,time);clearTimeout(tID)</p>
					<h5>3>>.screen对象[屏幕],用于获取用户显示屏分辨率和色彩信息</h5>
					<h5>4>>.history对象[历史]:包含用户(在浏览器窗口内)访问过的url</h5>
					<p>history.forward(); //等同于单击"前进"按钮</p>
					<p>history.back();//等同于单击"后退"按钮</p>
					<p>history.go(-2);//等同于单击两次"后退"按钮</p>
					<h5>5>>.location对象[地址栏]：包含当前url信息</h5>
					<p>reload();重新载入当前网址，相当于按下“刷新“,location.href="#"相当于超链接a，不过这个可以用js再加以控制</p>
					<h5>6>>.navigator对象[帮助]:获取客户端浏览器和操作系统信息</h5>
					<p>navigator.userAgent;//获取到信息</p>
				</div>
				<h4>6.自定义对象：java雷同</h4>
<pre>
		function obj(){
			var aobj=new Object();//创建对象
			aobj.name="xyu";//添加属性
			aobj.age="28";
			aobj.say=new Function("alear("你好！");");//添加方法
			aobj.say();//测试
		}
</pre>
				<h4>7.事件</h4>
				<div style="width:88%;margin:20px auto">
				<h5>鼠标事件:</h5>
				<p><span>onclick</span><span>ondblclick</span>
					<span>onmousedown</span><span>onmouseup</span>
					<span>onmouseover</span><span>onmouseout</span>
				</p>
				<h5>键盘事件:</h5>
				<p><span>onkeydown</span><span>onkeyup</span></p>
				<h5>状态事件:</h5>
					<p><span>onload[页面加载后事件]</span><span>onchange[内容改变时触发事件]</span>
					<span>onfocus[获取焦点事件]</span><span>onblur[释放焦点事件]</span><span>onsubmit</span>
				</p>
				<h3>event对象：</h3>
				<p>事件触发后会产生event对象,event对象记录了事件发生时鼠标位置、键盘按键状态、触发对象等信息</p>
				<p>获取鼠标位置：event.clintX/Y;</p>
				<p>浏览器兼容问题，有些浏览器event不能直接用，可用当参数传入</p>
<pre>
		onclick="func(event);"
		//js代码:
		function func(e){
			aleat(e.clientX+","+e.clicntY):
		}
</pre>
				<h4>获取事件源:enent.srcElement[ie];event.target[Firefox]</h4>
				<p>案例:计算器</p>
<pre>
	&lt;script>
    	window.onload = function() {
    		//给div绑定单击事件
    		var div = document.getElementById("jsq");
    		div.onclick = function(e) {
    			//获取事件源
    			var obj = e.srcElement || e.target;//获取事件源:enent.srcElement[ie];event.target[Firefox]
    			//处理其中的INPUT
    			if(obj.nodeName == "INPUT") {
    				var p = document.getElementById("screen");
    				if(obj.value == "=") {
    					try {
	    					p.innerHTML = eval(p.innerHTML);
    					} catch(ex) {
    						p.innerHTML = "Error";
    					}
    				} else if(obj.value == "C") {
    					p.innerHTML = "";
    				} else {
    					p.innerHTML += obj.value;
    				}
    			}
    		}
    	}
    &lt;/script>
  &lt;/head>
  &lt;body>
    &lt;div class="panel" id="jsq">
      &lt;div>
        &lt;p id="screen">&lt;/p>
        &lt;input type="button" value="C">
        &lt;div style="clear:both">&lt;/div>
      &lt;/div>
      &lt;div>
        &lt;input type="button" value="7">
        &lt;input type="button" value="8">
        &lt;input type="button" value="9">
        &lt;input type="button" value="/">
        
        &lt;input type="button" value="4">
        &lt;input type="button" value="5">
        &lt;input type="button" value="6">
        &lt;input type="button" value="*">
        
        &lt;input type="button" value="1">
        &lt;input type="button" value="2">
        &lt;input type="button" value="3">
        &lt;input type="button" value="-">
        
        &lt;input type="button" value="0">
        &lt;input type="button" value=".">
        &lt;input type="button" value="=">
        &lt;input type="button" value="+">
        
        &lt;div style="clear:both">&lt;/div>
      &lt;/div>
    &lt;/div>    
</pre>
				<h4>事件处理机制:冒泡机制【一次激活其他事件】</h4>
				<p>事件冒泡,就像在水底产生的一个水泡,一层一层向上走如在button上的click事件,会一层层向上走,最后document会得到一个click事件</p>
				<p>event.stopPropagation停止事件的冒泡</p>
				<p>设置cancelBubble =true后, 就不会向上冒泡了.[默认是false向上冒泡]</p>
				</div>

				<div>8.自定义对象:</div>
<pre>
function start(){
	var student={
	"name":"xiaoyu",
	"age":"28",
	"say":"function(){
		alert("我是我");
		}"
	}
	alert(student.name);//xiaoyu
	student.say();

}
</pre>
				<p>自定义对象中：构造器名首字母大写[规范]</p>
			</div>			
		</div>
	</body>
</html>